        function createRandomObjects() {
            const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
            const sphereGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const pyramidGeometry = new THREE.ConeGeometry(1.5, 3, 4);
            
            const materials = [
                new THREE.MeshPhongMaterial({ color: 0xff4444 }),
                new THREE.MeshPhongMaterial({ color: 0x44ff44 }),
                new THREE.MeshPhongMaterial({ color: 0x4444ff }),
                new THREE.MeshPhongMaterial({ color: 0xffff44 }),
                new THREE.MeshPhongMaterial({ color: 0xff44ff }),
                new THREE.MeshPhongMaterial({ color: 0x44ffff })
            ];
            
            // Create cubes
            for (let i = 0; i < 15; i++) {
                const material = materials[Math.floor(Math.random() * materials.length)];
                const cube = new THREE.Mesh(cubeGeometry, material);
                cube.position.set(
                    (Math.random() - 0.5) * 80,
                    Math.random() * 10 + 1,
                    (Math.random() - 0.5) * 80
                );
                cube.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                cube.castShadow = true;
                cube.receiveShadow = true;
                scene.add(cube);
                cubes.push(cube);
            }
            
            // Create spheres
            for (let i = 0; i < 10; i++) {
                const material = materials[Math.floor(Math.random() * materials.length)];
                const sphere = new THREE.Mesh(sphereGeometry, material);
                sphere.position.set(
                    (Math.random() - 0.5) * 80,
                    Math.random() * 10 + 1,
                    (Math.random() - 0.5) * 80
                );
                sphere.castShadow = true;
                sphere.receiveShadow = true;
                scene.add(sphere);
                spheres.push(sphere);
            }
            
            // Create pyramids
            for (let i = 0; i < 8; i++) {
                const material = materials[Math.floor(Math.random() * materials.length)];
                const pyramid = new THREE.Mesh(pyramidGeometry, material);
                pyramid.position.set(
                    (Math.random() - 0.5) * 80,
                    Math.random() * 10 + 1.5,
                    (Math.random() - 0.5) * 80
                );
                pyramid.rotation.y = Math.random() * Math.PI;
                pyramid.castShadow = true;
                pyramid.receiveShadow = true;
                scene.add(pyramid);
                pyramids.push(pyramid);
            }
        }
        
        // Set up event listeners for mouse and keyboard
        function setupEventListeners() {
            // Mouse lock on canvas click
            const canvas = renderer.domElement;
            canvas.addEventListener('click', () => {
                canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
                canvas.requestPointerLock();
            });
            
            // Mouse lock change events
            document.addEventListener('pointerlockchange', lockChange, false);
            document.addEventListener('mozpointerlockchange', lockChange, false);
            
            // Mouse movement for camera rotation
            document.addEventListener('mousemove', onMouseMove, false);
            
            // Keyboard controls
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            
            // Window resize
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function lockChange() {
            if (document.pointerLockElement === renderer.domElement ||
                document.mozPointerLockElement === renderer.domElement) {
                isMouseLocked = true;
                document.getElementById('crosshair').style.display = 'block';
            } else {
                isMouseLocked = false;
                document.getElementById('crosshair').style.display = 'none';
            }
        }
        
        function onMouseMove(event) {
            if (!isMouseLocked) return;
            
            const movementX = event.movementX || event.mozMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || 0;
            
            // Update yaw and pitch based on mouse movement
            yaw -= movementX * 0.002;
            pitch -= movementY * 0.002;
            
            // Clamp pitch to prevent camera flipping
            pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            
            // Update camera rotation
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
        }
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    moveUp = true;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    moveDown = true;
                    break;
                case 'Escape':
                    if (document.exitPointerLock) {
                        document.exitPointerLock();
                    } else if (document.mozExitPointerLock) {
                        document.mozExitPointerLock();
                    }
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'Space':
                    moveUp = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    moveDown = false;
                    break;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Update camera position based on keyboard input
        function updateCamera(deltaTime) {
            // Movement speed
            const speed = 10.0;
            
            // Calculate movement direction based on camera orientation
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.y = Number(moveUp) - Number(moveDown);
            direction.normalize();
            
            // Apply movement relative to camera orientation
            if (moveForward || moveBackward) {
                velocity.z -= direction.z * speed * deltaTime;
            }
            if (moveLeft || moveRight) {
                velocity.x -= direction.x * speed * deltaTime;
            }
            if (moveUp || moveDown) {
                velocity.y -= direction.y * speed * deltaTime;
            }
            
            // Apply some friction
            velocity.x *= 0.9;
            velocity.y *= 0.9;
            velocity.z *= 0.9;
            
            // Move camera
            camera.translateX(-velocity.x * deltaTime);
            camera.translateY(-velocity.y * deltaTime);
            camera.translateZ(-velocity.z * deltaTime);
            
            // Keep camera above ground
            if (camera.position.y < 1) {
                camera.position.y = 1;
                velocity.y = 0;
            }
            
            // Update stats
            updateStats();
        }
        
        // Update position and rotation stats
        function updateStats() {
            document.getElementById('pos-x').textContent = camera.position.x.toFixed(2);
            document.getElementById('pos-y').textContent = camera.position.y.toFixed(2);
            document.getElementById('pos-z').textContent = camera.position.z.toFixed(2);
            document.getElementById('rot-x').textContent = (pitch * 180 / Math.PI).toFixed(1);
            document.getElementById('rot-y').textContent = (yaw * 180 / Math.PI).toFixed(1);
        }
        
        // Update FPS counter
        function updateFPS() {
            frameCount++;
            const now = performance.now();
            
            if (now >= lastFpsUpdate + 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = now;
                document.getElementById('fps').textContent = fps;
            }
        }
        
        // Animate objects
        function animateObjects(deltaTime) {
            // Rotate cubes
            cubes.forEach(cube => {
                cube.rotation.x += 0.5 * deltaTime;
                cube.rotation.y += 0.3 * deltaTime;
            });
            
            // Bounce spheres
            spheres.forEach((sphere, index) => {
                sphere.position.y = 1.5 + Math.sin(performance.now() * 0.001 + index) * 0.5;
            });
            
            // Rotate pyramids
            pyramids.forEach(pyramid => {
                pyramid.rotation.y += 0.2 * deltaTime;
            });
        }
        
        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const deltaTime = (time - prevTime) / 1000;
            prevTime = time;
            
            // Update camera movement
            updateCamera(deltaTime);
            
            // Animate scene objects
            animateObjects(deltaTime);
            
            // Update FPS counter
            updateFPS();
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Start the application when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
