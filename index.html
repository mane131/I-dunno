<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>3D Sandbox Explorer</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
    background-color: #111;
    color: #fff;
  }
  #startMenu {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.8);
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    z-index: 10;
  }
  #startMenu h1 {
    margin-bottom: 20px;
    font-size: 2rem;
    color: #4CAF50;
  }
  #startButton {
    padding: 15px 30px;
    font-size: 1.2rem;
    background: #4CAF50;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.3s;
  }
  #startButton:hover { background: #45a049; }

  #container {
    width: 100vw;
    height: 100vh;
    position: relative;
  }

  #canvas-container {
    width: 100%; height: 100%;
    cursor: grab;
  }

  #crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    pointer-events: none;
    display: none;
  }
  .crosshair-dot {
    position: absolute;
    width: 4px; height: 4px;
    background-color: white;
    border-radius: 50%;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
  }
  .crosshair-line {
    position: absolute;
    background-color: white;
  }
  .horizontal {
    width: 12px; height: 2px;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
  }
  .vertical {
    width: 2px; height: 12px;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
  }

  #ui {
    position: absolute;
    top: 20px; left: 20px;
    background-color: rgba(0,0,0,0.7);
    padding: 15px;
    border-radius: 10px;
    max-width: 300px;
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255,255,255,0.1);
    display: none;
    z-index: 5;
  }
  #ui h1 {
    font-size: 1.5rem;
    margin-bottom: 10px;
    color: #4CAF50;
  }
  #ui p {
    font-size: 0.9rem;
    line-height: 1.5;
    margin-bottom: 5px;
  }
  #stats {
    position: absolute;
    bottom: 20px; right: 20px;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 5px;
    font-family: monospace;
    font-size: 0.8rem;
    z-index: 5;
  }
</style>
</head>
<body>
<div id="startMenu">
  <h1>3D Sandbox Explorer</h1>
  <button id="startButton">Start Sandbox</button>
</div>

<div id="container">
  <div id="canvas-container"></div>
  <div id="crosshair">
    <div class="crosshair-dot"></div>
    <div class="crosshair-line horizontal"></div>
    <div class="crosshair-line vertical"></div>
  </div>
  <div id="ui">
    <h1>Controls</h1>
    <p>Look around by moving your mouse. Use W/A/S/D to walk, Space to go up, Shift to go down.</p>
    <p>Click on the view to enable mouse look. Press ESC to exit mouse look.</p>
  </div>
  <div id="stats">
    <div>Position: <span id="pos-x">0</span>, <span id="pos-y">0</span>, <span id="pos-z">0</span></div>
    <div>Rotation: <span id="rot-x">0</span>, <span id="rot-y">0</span></div>
    <div>FPS: <span id="fps">0</span></div>
  </div>
</div>

<!-- Include Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  // Variables
  let scene, camera, renderer;
  let cubes = [], spheres = [], pyramids = [];
  let plane;
  let isMouseLocked = false;
  let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, moveUp=false, moveDown=false;
  let velocity=new THREE.Vector3(), direction=new THREE.Vector3();
  let prevTime=performance.now();
  let fps=0, frameCount=0, lastFpsTime=performance.now();
  let animationId;

  const startMenu = document.getElementById('startMenu');
  const startButton = document.getElementById('startButton');
  const ui = document.getElementById('ui');
  const crosshair = document.getElementById('crosshair');

  // Initialize scene after clicking start
  startButton.onclick = () => {
    startMenu.style.display='none';
    init();
  };

  function init() {
    // Scene
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x87CEEB, 10, 200);

    // Camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(0, 5, 15);

    // Renderer
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff,0.6);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
    dirLight.position.set(50,100,50);
    dirLight.castShadow=true;
    scene.add(dirLight);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(200,200);
    const groundMat = new THREE.MeshPhongMaterial({color:0x3a7c3a, side:THREE.DoubleSide});
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x=Math.PI/2;
    ground.receiveShadow=true;
    scene.add(ground);

    // Add grid helper
    const gridHelper = new THREE.GridHelper(200,50,0x000000,0x000000);
    gridHelper.material.opacity=0.2;
    gridHelper.material.transparent=true;
    scene.add(gridHelper);

    // Create objects
    createObjects();

    // Event listeners
    setupEventListeners();

    // Show controls after starting
    ui.style.display='block';

    // Start animation
    animate();
  }

  function createObjects() {
    const cubeGeo = new THREE.BoxGeometry(2,2,2);
    const sphereGeo = new THREE.SphereGeometry(1,16,16);
    const pyramidGeo = new THREE.ConeGeometry(1.5,3,4);
    const materials = [
      new THREE.MeshPhongMaterial({color:0xff4444}),
      new THREE.MeshPhongMaterial({color:0x44ff44}),
      new THREE.MeshPhongMaterial({color:0x4444ff}),
      new THREE.MeshPhongMaterial({color:0xffff44}),
      new THREE.MeshPhongMaterial({color:0xff44ff}),
      new THREE.MeshPhongMaterial({color:0x44ffff})
    ];

    // Cubes
    for (let i=0; i<15; i++) {
      const mat = materials[Math.floor(Math.random()*materials.length)];
      const cube = new THREE.Mesh(cubeGeo, mat);
      cube.castShadow=true;
      cube.receiveShadow=true;
      cube.position.x=(Math.random()-0.5)*100;
      cube.position.z=(Math.random()-0.5)*100;
      cube.position.y=1;
      cube.rotation.y=Math.random()*Math.PI*2;
      scene.add(cube);
      cubes.push(cube);
    }

    // Spheres
    for (let i=0; i<10; i++) {
      const mat=materials[Math.floor(Math.random()*materials.length)];
      const sphere=new THREE.Mesh(sphereGeo, mat);
      sphere.castShadow=true;
      sphere.receiveShadow=true;
      sphere.position.x=(Math.random()-0.5)*100;
      sphere.position.z=(Math.random()-0.5)*100;
      sphere.position.y=1;
      scene.add(sphere);
      spheres.push(sphere);
    }

    // Pyramids
    for (let i=0; i<8; i++) {
      const mat=materials[Math.floor(Math.random()*materials.length)];
      const pyramid=new THREE.Mesh(pyramidGeo, mat);
      pyramid.castShadow=true;
      pyramid.receiveShadow=true;
      pyramid.position.x=(Math.random()-0.5)*100;
      pyramid.position.z=(Math.random()-0.5)*100;
      pyramid.position.y=1.5;
      pyramid.rotation.y=Math.random()*Math.PI*2;
      scene.add(pyramid);
      pyramids.push(pyramid);
    }
  }

  function setupEventListeners() {
    // Mouse lock
    renderer.domElement.addEventListener('click', () => {
      renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock || renderer.domElement.mozRequestPointerLock;
      renderer.domElement.requestPointerLock();
    });
    document.addEventListener('pointerlockchange', onPointerLockChange);
    document.addEventListener('mozpointerlockchange', onPointerLockChange);

    // Keyboard
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    // Resize
    window.addEventListener('resize', onWindowResize);
  }

  function onPointerLockChange() {
    isMouseLocked = document.pointerLockElement===renderer.domElement || document.mozPointerLockElement===renderer.domElement;
    if (isMouseLocked) {
      document.addEventListener('mousemove', onMouseMove);
      crosshair.style.display='block';
    } else {
      document.removeEventListener('mousemove', onMouseMove);
      crosshair.style.display='none';
    }
  }

  function onMouseMove(e) {
    if (!isMouseLocked) return;
    const movementX = e.movementX || e.mozMovementX || 0;
    const movementY = e.movementY || e.mozMovementY || 0;
    camera.rotation.y -= movementX * 0.002;
    camera.rotation.x -= movementY * 0.002;
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
  }

  function onKeyDown(e) {
    switch(e.code) {
      case 'KeyW': moveForward=true; break;
      case 'KeyA': moveLeft=true; break;
      case 'KeyS': moveBackward=true; break;
      case 'KeyD': moveRight=true; break;
      case 'Space': moveUp=true; break;
      case 'ShiftLeft':
      case 'ShiftRight': moveDown=true; break;
      case 'Escape':
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
        document.exitPointerLock();
        break;
    }
  }

  function onKeyUp(e) {
    switch(e.code) {
      case 'KeyW': moveForward=false; break;
      case 'KeyA': moveLeft=false; break;
      case 'KeyS': moveBackward=false; break;
      case 'KeyD': moveRight=false; break;
      case 'Space': moveUp=false; break;
      case 'ShiftLeft':
      case 'ShiftRight': moveDown=false; break;
    }
  }

  function onWindowResize() {
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function updateMovement(delta) {
    const speed=20*delta;
    velocity.x=0; velocity.z=0; velocity.y=0;

    // Horizontal movement
    const dirX=Number(moveRight)-Number(moveLeft);
    const dirZ=Number(moveBackward)-Number(moveForward);
    const dirY=Number(moveUp)-Number(moveDown);

    // forward/backward
    if (dirZ!==0) {
      velocity.x -= dirZ * Math.sin(camera.rotation.y) * speed;
      velocity.z -= dirZ * Math.cos(camera.rotation.y) * speed;
    }
    // left/right
    if (dirX!==0) {
      velocity.x -= dirX * Math.cos(camera.rotation.y) * speed;
      velocity.z += dirX * Math.sin(camera.rotation.y) * speed;
    }
    // up/down
    velocity.y += dirY * speed;

    // Apply to camera
    camera.position.x += velocity.x;
    camera.position.y += velocity.y;
    camera.position.z += velocity.z;

    // Keep above ground
    if (camera.position.y<5) {
      camera.position.y=5;
    }

    updateUI();
  }

  function updateUI() {
    document.getElementById('pos-x').textContent=camera.position.x.toFixed(1);
    document.getElementById('pos-y').textContent=camera.position.y.toFixed(1);
    document.getElementById('pos-z').textContent=camera.position.z.toFixed(1);
    document.getElementById('rot-x').textContent=(camera.rotation.x*180/Math.PI).toFixed(1);
    document.getElementById('rot-y').textContent=(camera.rotation.y*180/Math.PI).toFixed(1);
  }

  function updateFPS() {
    frameCount++;
    const now=performance.now();
    if (now - lastFpsTime >= 1000) {
      fps = Math.round((frameCount * 1000) / (now - lastFpsTime));
      frameCount=0;
      lastFpsTime=now;
      document.getElementById('fps').textContent=fps;
    }
  }

  function animate() {
    animationId = requestAnimationFrame(animate);
    const now=performance.now();
    const delta=(now - prevTime)/1000;
    prevTime=now;

    updateMovement(delta);
    
    // Animate objects
    cubes.forEach(c => c.rotation.y += 0.005);
    spheres.forEach(s => s.position.y=1 + Math.sin(now*0.001 + s.position.x)*0.5);
    pyramids.forEach(p => p.rotation.y += 0.003);

    updateFPS();

    renderer.render(scene, camera);
  }

</script>
</body>
</html>
